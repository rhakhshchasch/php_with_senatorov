03.04.2023 - написали логику калькулятора, сделали его рабочим:
1. Получили из $_POST значения по именам данных с фронта.
2. Прописали цикл на правильное вычисление результатов.
3. Добавили в цикл проверку существования данных и защиту от деления на ноль
4. Проверкой по isset() (9 строка на бэке) избавились от предупреждений при запуске калькулятора
5. Изменил проверку значений и is_empty() на '== NULL'. Начало отрабатывать предупреждение о делении на ноль.
   is_null() при этом выдаёт какую-то ошибку.
6. Переписал на фронте тип данных членов выражения с number на float. Появилась возможность использовать 
   дробные числа.




04.04.2023 -  сделали ещё 2 калькулятора, на простом switch и на switch с использованием функций:
1. Я узнал, что типа float в HTML не существует. И, соответственно, PHP - язык с динамической типизацией 
   (можно писать что и как угодно и многое будет прощено)
2. Сделали калькулятор на простом switch
3. Сделали калькулятор на switch с использованием функций
4. Ссылка на функции идёт с аргументами
5. switch - это замена условной конструкции, понимаю возможные случае их использования




05.04.2023 - изучили работу циклов while(), for(), foreach()
1. Цикл while() на обычном синтаксисе. Начальное значение задаётся отдельно. Инкремент в теле цикла.
   Пример: 
	$i = 2; 
	while($i < 4) 
	{...; $i++;}
2. Цикл while() на альтернативном синтаксисе. Тело открывается с помощью :  Закрывается endwhile;
3. Цикл for() на обычном синтаксисе. Начальное значение задаётся в описании. Инкремент в описании.
   Пример: 
	for($i = 2; $i < 4; $i++) 
	{...;}
4. Цикл for() на альтернативном синтаксисе.  Тело открывается с помощью :  Закрывается endfor;
5. Прикол циклов на альтернативном синтаксисе в вёрстке в том, что открытие и закрытие 
   прописывваются в отдельных <?php ... ?> инструкциях на разных строках. 
   А между ними можно поместить неограниченно кода, который будет повторяться.
6. Цикл foreach(). Работает с массивом. По умолчанию сам перебирает все элементы.
   Пример: 
	$num = [2, 3]; 
	foreach($num as $key => $value) 
	{...;}
7. Изучили три варианта вывода строк с помощью оператора echo. 
	7.1. Строка в "", элементы в ''.
	     Прикол в том, что без лишних движений можно дать ссылку на переменную с помощью {}
	     Пример: 
	     echo "<input type='text' name='num{$i}' id=''><br><br>";
	7.2. Строка в "", элементы в "", экранирование с помощью \.
	     Прикол тот же самый, что и 7.1, но тяжелее читать.
	     Пример: 
	     echo "<input type=\"text\" name=\"num{$i}\" id=\"\"><br><br>";
	7.3. Строка в '', элементы также в "".
	     Прикол в том, что строку можно просто скопировать и не париться с заменой кавычек. 
	     Минус в том, что переменную нужно упоминать с помощью конкатенации, можно забыть и запутуться.
	     Пример: 
	     echo '<input type="text" name="num' . $i . '" id=""><br><br>';
   Предпочтительным является вариант 7.1.




06.04.2023 - познакомились с функциями поближе
1. Параметр функции = Аргумент функции.
2. Помимо параметров, которые в функцию нужно передавать, можно задать параметры по умолчанию.
   Пример (по умолчанию задаём $num3):
   function add($num1, $num2, $num3 = 5){...;}
3. Задача функции - (правильно отработать и) вывести результат.
4. Поэтому функция встречается дважды: при объявлении функции и при вызове функции (для работы).
   Объявление = Инициализация.
5. При вызове функции можно заменить значения параметров.
   Пример (меняем $num3):
   function add($num1, $num2, $num3 = 5){...;}
   $num1 = ... ;   $num2 = ... ;
   ...
   ... $result = add($num1, $num2, 0);
5. Помимо объявления функции нужно объявить аргументы, над которыми функция будет работать.
6. Функция - это "закрытый контейнер".
   Переменные внутри тела функции - локальные, за пределами функции - глобальные.
7. Функция видит глобальные переменные, но "снаружи" нельзя прочитать локальные переменные.
8. Есть строгая (жёсткая) типизация или type hinting, объявляется первой строкой: declare(strict_types=1);
   Что это такое я не понял. И пока не пойму, за такие проекты лучше не браться.




07.04.2023 - начали знакомиться с AJAX
1. jQuery - это набор функций (библиотека) JavaScript, фокусирующийся на взаимодействии JavaScript и HTML.
2. AJAX - это один из методов jQuery.
3. AJAX передают данные с фронта на бэк и выводит ответ бэка без перезагрузки страницы.
4. jQuery подключается в теге <head> до подключения файла с JS кодом.
5. В части передачи данных AJAX-запрос по сути представляет собой ассоциативный массив (ключ : значение).
6. Также в AJAX-запросе прописываются варианты исполнения: beforeSend, success, error, complete.
7. Пример:
	var i = 0;
	function AjaxSendForm(url, placeholder, form, append) {
	var data = $(form).serialize();
	append = (append === undefined ? false : true); // whatever, it will evaluate to true or false only
	$.ajax({
    		type: 'POST',
    		url: url,
    		data: data,
    		beforeSend: function() {
        	// setting a timeout
        	$(placeholder).addClass('loading');
        	i++;
    	},
    		success: function(data) {
        		if (append) {
            		$(placeholder).append(data);
        		} else {
            		$(placeholder).html(data);
        		}
    		},
  		error: function(xhr) { // if error occured
       			alert("Error occured.please try again");
        		$(placeholder).append(xhr.statusText + xhr.responseText);
       	 		$(placeholder).removeClass('loading');
    		},
    		complete: function() {
        		i--;
       			if (i <= 0) {
        		$(placeholder).removeClass('loading');
        		}
    		},
    		dataType: 'html'
		});
	}
   (https://stackoverflow.com/questions/21648356/jquery-ajax-beforesend-and-success-error-complete)




08.04.2023 - продолжили знакомиться с AJAX
1. значение "json" в параметре "dataType" AJAX-запроса значит что фронт будет ждать ответ от сервера 
   в формате "json".
2. Формат "json" конвертирует данные в строку. 
3. Есть какая-то проблема у json и var_dump.     !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
4. Параметр "data" показывает какие данные передаются на сервер.
5. К параметрам "data" можно обратиться по ключу.
   Пример:
   $.ajax({
	url: '/php_Aleksey/main/php/calculator_function_AJAX/controller/calculator.php',
	method: 'post',
	dataType: 'json',
	data: {text: 'Текст'},
		success: function(data){
			console.log(data.text);
		},
    	...
   });
   В консоль выведет просто "Текст"




10.04.2023 - зарегались на Weblancer, оформили профили в Telegram и GitHub




11.04.2023 - продолжили знакомиться с AJAX (ещё раз)
1. Запуск AJAX начинается с 
   $(document).ready(function(){   ...   })
2. $(document) - это весь документ <html></html> 
   .ready() - это условие прогрузки документа 
   function() - это синтаксис вызова функции, которую мы пропишем в теле.
3. Присвоение имени событию:
   $('#form').submit(function (event) {   ...   })
4. #form - поиск по id="form"
   .submit() - условие отправки формы (наступления события)
5. Отмена поведения по умолчанию - event.preventDefault();       зачем???!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1
6. let form = $(this);
   let - объявление локальной переменной 
   form = $(this);  -  form - это имя переменной; $(this) - часть, ссылающаяся на последнюю объявленную 
   переменную   ?????????????????!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
7. dataType: 'json' выбирает с бэка часть данных для передачи в формате 'json'. В то время как, например 
   'html' будет выбирать только данные 'html' и игнорировать данные 'json'
8. data: form.serialize()  -  .serialize() обеспечивает передачу form массивом, не вразброс.
9. Поскольку данные на бэк передаёт AJAX, из формы 
   <form class="form-message" id="form" action="controller/calculator.php" method="POST"> 
   можно удалить action и method 




12.04.2023 - переписали калькулятор на AJAX
1. Поскольку выводим результат в одно поле, переписали все возможные варианты вывода (корректный результат 
   и ошибки "You cannot divide by zero" и "Enter both values first") на присвоение результату $result
2. Поскольку ошибка "Enter both values first" и $result лежали в разных (вложенных) циклах, 
   перенесли вывод результата в верхнюю ветку цикла. 
   Вывод:
   $result = json_encode(["Result" => $result]); 
   if(isset($result)) echo $result;
3. В выводе прописали $result как ассоциативный массив и в дальнейшем будем обращаться к результату 
   по ключу "Result"
4. jS регистрозависимый язык, то есть ключ "Result" по ключу "result" не найдёт.
5. Метод .serialize() не передаёт значение кнопки submit, поэтому добавили в форму не фронте ещё 
   одно поле с типом "hidden" (value="true"):
   <input type="hidden" name="submit" value="1">
6. На этом этапе всё для корректной работы бэка уже написано. 
   submit передаётся на бэк и $result передаётся на фронт. Осталось прописать где отображать.
7. Чтобы не запариваться с назначением стиля <p>...</p>, прописали через <div>...</div>
   Вывод на фронте:
   <div id="AJAX"> Итого: <div id="ajaxResult"></div></div>
8. В завершение прописали передачу данных с AJAXa на фронт:
   ...
   success: function(output){
   	const result = output.Result;
   	$("#ajaxResult").html(result);
   }, ...
   То есть, именуем вывод с бэка как output. Определяем переменную result, которой по ключу "Result" 
   присваиваем извлеченный $result
   Далее, методом .html() передаем result (он же $result) на фронт в поле с id="ajaxResult"
9. ВАЖНО:
   На этапе, когда мы передаём данные на фронт с помощью
   success: function(output){
   console.log(output);
   }, ...
   по выводу в консоли мы можем понять, как отрабатывает фронт.
   Можем менять dataType на 'json' или 'html', либо вообще комментить и смотреть вывод в консоли. 
   При dataType: 'json' ошибка 'Requested JSON parse failed.' значит, что с бэка передаётся как минимум 
   не только json.
   Что именно, можем уточнить при переключении dataType на 'html' или даже 'text'




14.04.2023 - создали новый репозиторий calculator-php-ajax и добавили favicon.ico в <head></head>




15.03.2023 - запуллил коммиты на проверку ввода только цифер; проработали массивы
1.  Проверка на число: !is_numeric($num1) - не есть число.
2.  Хороший тон: перед работой с массивом объявляем его: 
    $array = [];
3.  Ассоциативный массив задаётся парами "ключ" - "значение"
    Пример:
    $array = ['name' => 'Aleksei', 'surname' => 'Pershikov'];
4.  (АМ) Дополняется одним значением как:
    $array['teacher'] = 'Ruslan Senatorov';
5.  (АМ) Дополняется несколькими значениями как:
    $array += ['wannabe' => 'PHP developer', 'to_loot' => 'money'];
6.  Автомассив или числовой массив. Записываются только значения, ключ - индекс элемента.
7.  ВАЖНО: Ассоциативный массив затирает автомассив. Но автомассив добавляет элементы в ассоциативный
8.  (ЧМ) Дополняется одним значением как:
    $array[] = 'PHP developer';                                            (индекс 0)
9.  (ЧМ) Дополняется несколькими значениями как:
    array_push($array, 'Fullstack developer', 'Python developer');         (индекс 1, 2)
10. Для добавления одного значения лучше 8, чем 9, потому что нет затрат на вызов функции.
11. Удаление элемента из массива:     unset($array[0]); - в [] - индекс или значение ключа.
12. Также числовой массив заполняется циклом foreach. 
    Пример: 
    $fruits = ['name1' => 'apple', 'name2' => 'banana', 'name3' => 'mango'];
    $new_array = [];
    foreach($fruits as $value){
    $new_array[] = $value;
    }
    Массив $fruits - симуляция любой выгрузки из базы данных.
    Массив $new_array - новый числовой массив. 
    Цикл foreach() предназначен для работы с массивами. Сам определяет начало и конец и пробегает 
    по всем элементам (неважно, какой массив у нас на входе).
13. Инструкция exit(); даёт интерпритатору команду остановиться и прекратить выполнение программы.
    Используется для дебаггинга.




18.04.2023 - Начали знакомиться с ООП
1. Класс — это шаблон для объектов, а объект — это экземпляр класса.
   Пример создания класса:
        class Person {   ...   }
2. Класс состоит из свойств и методов.
3. Свойства класса - это данные (переменные).
        public static $name; где:
        public - модификатор доступа, 
        static - обращение от класса к свойству без создания объекта (экземпляра класса)
4. Методы класса - это функции.
   Пример функции:
        public static function setName($name) {
   	     self::$name = $name;
        }	где:
   self - ключевое слово как ссылка на текщий класс, :: - оператор разрешения области видимости
5. Свойства и методы public по умолчанию.
6. Методы делятся на геттеры и сеттеры. Сеттеры присваивают значения, геттеры выводят.




19.04.2023 - продолжили знакомиться с ООП
1. Чтобы создавать объекты на основе класса, мы добавляем в класс конструктор класса __construct() 
   Пример:
   public function __construct($name, $phone) {
        $this->name = $name;
        $this->phone = $phone;
   }
2. Конструктор класса вызывается автоматически при создании каждого объекта.
3. Конструкция типа ($this->var = $var;) используется для определения переменной при создании 
   объекта. Типо как "для объекта в качестве $var устанавливается "эта" $var"
4. Пример задания объекта:
   $customer1 = new Customer("Aleksei", "+123456789");		, где:
   $customer1 - объект,
   new - создание нового объекта на основе класса,
   Customer - название класса.
5. Если в классе
   class Customer {
   	public $name;
   	private $phone;   ...   },
   то $name можно изменять снаружи, потому что public,
   а $phone нельзя, потому что private.
6. Значение private свойства нельзя напрямую вывести через echo, только через геттер или var_dump()
